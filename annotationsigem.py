import matplotlib.pyplot as plt
from Bio import pairwise2
import pandas as pd
import numpy as np

match_score = 2       # Score for a match
mismatch_score = -1   # Penalty for a mismatch
gap_open_penalty = -0.5  # Penalty for opening a gap
gap_extend_penalty = -0.1  # Penalty for extending a gap

def calculate_alignment_scores(long_seq, short_seqs, window_size):
    max_score = window_size * match_score
    step_size = 1  # For every position

    all_positions = []
    all_normalized_scores = []
    all_alignment_results = []

    for short_name, short_seq in short_seqs.items():
        positions = []
        normalized_scores = []
        alignment_results = []

        for i in range(0, len(long_seq) - window_size + 1, step_size):
            window = long_seq[i:i + window_size]
            local_alignments = pairwise2.align.localms(window, short_seq, match_score, mismatch_score, gap_open_penalty, gap_extend_penalty)

            best_alignment_score = float("-inf")
            best_alignment = None

            for alignment in local_alignments:
                alignment_score = alignment[2]
                normalized_score = alignment_score / max_score

                if alignment_score > best_alignment_score:
                    best_alignment_score = alignment_score
                    best_alignment = alignment

            if best_alignment:
                position = i
                positions.append(position)
                normalized_scores.append(normalized_score)

                alignment_result = (position, window, normalized_score)
                alignment_results.append(alignment_result)

        # Handle the end of the sequence
        for i in range(len(long_seq) - window_size + 1, len(long_seq), step_size):
            window = long_seq[i:]
            current_window_size = len(window)
            local_alignments = pairwise2.align.localms(window, short_seq, match_score, mismatch_score, gap_open_penalty, gap_extend_penalty)

            best_alignment_score = float("-inf")
            best_alignment = None

            for alignment in local_alignments:
                alignment_score = alignment[2]
                normalized_score = alignment_score / (current_window_size * match_score)

                if alignment_score > best_alignment_score:
                    best_alignment_score = alignment_score
                    best_alignment = alignment

            if best_alignment:
                position = i
                positions.append(position)
                normalized_scores.append(normalized_score)

                alignment_result = (position, window, normalized_score)
                alignment_results.append(alignment_result)

        all_positions.append(positions)
        all_normalized_scores.append(normalized_scores)
        all_alignment_results.append(alignment_results)

    return all_positions, all_normalized_scores, all_alignment_results

def plot_alignment_scores(positions, normalized_scores, short_names):
    plt.figure(figsize=(14, 8))
    for short_name, short_positions, short_scores in zip(short_names, positions, normalized_scores):
        plt.plot(short_positions, short_scores, label=short_name)

    plt.xlabel('Position')
    plt.ylabel('Normalized Alignment Score')
    plt.title('Local Alignment Scores')
    plt.legend()
    plt.show()

def display_alignment_results(alignment_results, short_names):
    for short_name, short_results in zip(short_names, alignment_results):
        print(f"Alignment results for {short_name}:")
        df = pd.DataFrame(short_results, columns=['Position', 'Window', 'Normalized Score'])
        print(df)
        print()

def smooth_scores(scores, window_len):
    window = np.ones(window_len) / window_len
    return np.convolve(scores, window, mode='same')

def parse_annotations(data):
    regions = {}
    current_region = None
    start_pos = 0
    previous_annotation = None

    for line in data:
        pos, desc = line.split(": ")
        position = int(pos.split(" ")[1])
        annotation = desc.split(" has")[0]

        if current_region is None:
            current_region = annotation
            start_pos = position

        elif current_region != annotation:
            end_pos = position - 1

            if end_pos - start_pos + 1 < 10 and previous_annotation:
                current_region = previous_annotation

            if current_region in regions:
                # Merge intervals if the current region is the same as the previous
                if regions[current_region][-1][1] + 1 == start_pos:
                    regions[current_region][-1] = (regions[current_region][-1][0], end_pos)
                else:
                    regions[current_region].append((start_pos, end_pos))
            else:
                regions[current_region] = [(start_pos, end_pos)]
            
            previous_annotation = current_region
            current_region = annotation
            start_pos = position

    if current_region is not None:
        end_pos = position
        if end_pos - start_pos + 1 < 10 and previous_annotation:
            current_region = previous_annotation

        if current_region in regions:
            if regions[current_region][-1][1] + 1 == start_pos:
                regions[current_region][-1] = (regions[current_region][-1][0], end_pos)
            else:
                regions[current_region].append((start_pos, end_pos))
        else:
            regions[current_region] = [(start_pos, end_pos)]

    return regions

def main():
    main_sequence = 'MRASTLLILFCALQVMPSGDFGKIHITGSSTVIDKLENLLGHGHHLDGHNGLHERILAEDDVIEANSRGEIIEKIISRREIISDDNSYSASDSTEDSGSTEKIIKQIIIVQEKPKHGHHHAKEKIYEEEIIIKKIGDLPKHHIEVSKSISGEKRRRHGKSKHLPKSGLGHGVGGLGGIGGNKIWGPKVRRGSVSASYSVEIQQIVTPTVITDIKISGSVSVEGGRRGHGLGGHGLGHGLGHGLGGLGHGLGGLGHGLGGLGHGGLGGIGGRRGWGPKGRRGSVSASYSVEIQQIVTPTVITDIEISGSVSIEGGRRGHGLGGLGLGHGLGHGLGHGLGGLGHGGWGSSGDHSGIGGLGGLGGLGHLGGIGGRRGWGPKGRRGSVSASYSVEIQQIVTPTVITNIDISGSVSIEGGRRGHGLGGHGLGHGLGHGLGGLGHGLGGLGHGLGGLGHGGLGGIGGRKGWGPKGRRGSVSASYSVEIQQIVTPTVITDIEISGSVSIEGGRRGHGLGGLGLGHGLGHGLGHGLGGLGHGGWGSSGDHSGIGGLGGLGGLGHLGGIGGRRGWGPKGRRGSVSASYSVEIQQIVTPTVITNIDISGSVSIEGGRRGHGLGGLGLGHGLGHGLGHGLGGLGHGGWGSSGDHSGIGGLGGLGGLGHLGGIGGRRGWGPKGRRGSVSASYSVEIQQIVTPTVITNIDISGSVSIEGGRRGHGLGGLGLGHGLGHGLGHGLGGLGHGGWGSSGDHSGIGGLGGLGGLGHLGGIGGRRGWGPKGRRGSVSASYSVEIQQIVTPTVITNIDISGSVSIEGGRRGHGLGGHGLGHGLGHGLGGLGHGLGGLGHGLGGLGHGGLGGIGGRKGWGPKGRRGSVSASYSVEIQQIVTPTVITDIEISGSVSIEGGRRGHGLGGLGLGHGLGHGLGHGLGGLGHGGWGSSGDHSGIGGLGGLGGLGHLGGIGGRRGWGPKGRRGSASASYSVEIQQIVTPTVITNIDISGSVSIEGGRRGHGLGGHGLGHGLGHGLGGLGHGLGGLGHGLGGLGHGGLGGIGGRKGWGPKGRRGSVSASYSVEIQQIVTPTVITDIEISGSVSIEGGRRGHGLGGLGLGHGLGHGLGHGLGGLGHGGWGSSGDHSGIGGLGGLGGLGHLGGIGGRRGWGPKGRRGSVSASYSVEIQQIVTPTVITNIDISGSVSIEGGRRGHGLGGLGLGHGLGHGLGHGLGGLGRGGWGSSGDHSGIGGLGGLGGLGHLGGIGGRRGWGPKGRRGSVSASYSVEIQQIVTPTVITNIDISGSVSIEGGRRGHGLGGHGLGHGLGHGLGGLGHGLGGLGHGLGGLGHGGLGGIGGRKGWGPKGRRGSVSASYSVEIQQIVTPTVITNIDISGSVSIEGGRRGHGLGGLGLGHGLGHGLGHGLGGLGHGGWGSSGDHSGIGGLGGLGGLGHLGGIGGRKGWGPKGRRGSVSASYSVEIQQIVTPTVITNIDISGSVSIEGGRRGHGLGGHGLGHGLGHGLGGLGHGLGGLGHGLGGLGHGGLGGIGGRKGWGPKGRRGSVSASYSVEIQQIVTPTVITDIEISGSVSIEGGRRGHGLGGLGLGHGLGHGLGHGLGGLGHGGWGSSGDHSGIGGLGGLGGLGHLGGIGGRRGWRPKGRRGSVSASYSVEIQQIVTPTVITNIDISGSVSIEGGRRGHGLGGLGLGHGLGHGLGHGLGGLGRGGWGSSGDHSGIGGLGGLGGLGHLGGIGGRRGWGPKGRRGSVSASYSVEIQQIVTPTVITNIDISGSVSIEGGRRGHGLGGHGLGHGLGHGLGGLGHGLGGLGHGLGGLHGGLGGIGGRKGWGPKGRRGSVSASYSVEIQQIVTPTVITNIDISGSVSIEGGRRGHGLGGLGLGHGLGHGLGHGLGGLGHGGWGSSGDHSGIGGLGGLGGLGHLGGIGGRRGWGPKGRRGSVSASYSVEIQQIVTPTVITNIDISGSVSIEGGRRGHGLGGHGLGHGLGHGLGGLGHGLGGLGHGLGGLGHGGLGGIGGRKGWGPKGRRGSVSASYSVEIQQIVTPTVITDIEISGSVSIEGGRRGHGLGGLGLGHGLGHGLGHGLGGLGHGGWGSSGDHSGIGGLGGLGGLGHLGGIGGRRGWGPKGRRGSVSASYSVEIQQIVTPTVITNIDISGSVSIEGGRRGHGLGGLGLGHGLGHGLGHGLGGLGHGGWGSSGDHSGIGGLGGLGGLGHLGGIGGRRGWGPKGRRGSVSASYSVEIQQIVTPTVITNIDISGSVSIEGGRRGHGLGGLGLGHGLGHGLGHGLGGLGHGGWGSSGDHSGIGGLGGLGGLGHLGGIGGRRGWGPKGRRGSVSASYSVEIQQIVTPTVITNIDISGSVSIEGGRRGHGLGGHGLGHGLGHGLGGLGHGLGGLGHGLGGLGHGGLGGIGGRKGWGPKGRRGSVSASYSVEIQQIVTPTVITDIEISGSVSIEGGRRGHGLGGLGLGHGLGHGLGHGLGLGHGGWGSSGDHSGIEGLGGLGGLGHLGGIGGRRGWGPKGRRGSVSASYSVEIQQIVTPTVITNIDISGSVSIEGGRRGHGLGGLGLGHGLGHGLGHGLGGLGHGGWGSSGDHSGIGGGGLGGLGHLGGIGGRRGWGPKGRRGSVSASYSVEIQQIVTPTVITNIDISGSVSIEGGRRGHGLGGLGLGHGLGHGLGHGLGGLGHGGLGGIGGRKGWGPKGRRGSVSASYSVEIQQIVTPTVITDIEISGSVSIEGGRRGHGLGGLGLGHGLGHGLGHGLGGLGHGGWGSSGDHSGIGGLGGGLGHLGGIGGRRGWGPKGRRGSVSASYSVEIQQIVTPTVITNIDISGSVSIEGGRRGHGLGLGLGHGLGHGLGHGLGGLGHGGWGSSGDHSGIGGLGGLGGLGHLGGIGGRRGWGPKGRRGSVSASYSVEIQQIVTPTVITNIDISGSVSIEGGRRGHGLGGLGLGHGLGHGLGHGLGGLGHGGWGSSGDHSGIGGLGGLGGLGHLGGIGGRRGWGPKGRRGSVSASYSVEIQQIVTPTVITDIEISGSVSIEGGRRGHGLGGLGLGHGLGHGLGHGLGGLGHGGWGSSGDHSGIGGLGGLGGLGHLGGIGGRRGWGPKGRRGSVSASYSVEIQQIVTPTVITNIDISGSVSIEGGRRGHGLGGHGLGHGLGHGLGGLGHGLGGLGHGLGGLGHGGLGGIGGRRGWGPKGRRGSVSASYSVEIQQIVTPTVITDIEISGSVSIEGGRRGHGLGGLGLGHGLGHGLGHGLGGLGHGGWGSSGDHSGIGGLGGLGGLGHLGGIGGLRGWGPKGRRGSVSASYSVEIQQIVTPTVITNIDISGSVSIEGGRRGHGLGGHGLGHGLGHGLGGLGHGLGGLGHGLGGLGHGGLGGIGGRKGWGPKGRRGSVSASYSVEIQQIVTPTVITDIEISGSVSIEGGRRGHGLGGLGLGHGLGHGLGHGLGGLGHGGWGSSGDHSGIGGLGGLGGLGHLGGIGGRRGWGPKGRRGSVSASYSVEIQQIVTPTVITNIDISGSVSIEGGRRGHGLGGHGLGHGLGHGLGGLGHGLGGLGHGLGGLGHGGLGGIGGRKGWGPKGRRGSVSASYSVEIQQIVTPTVITDIEISGSVSIEGGRRGHGLGGLGLGHGLGHGLGHGLGGLGHGGWGSSGDHSGIGGLGGLGGLGHLGGIGGRRGWGPKGRRGSVSASYSVEIQQIVTPTVITNIDISGSVSIEGGRRGHGLGGLGLGHGLGHGLGHGLGGLGHGGWGSSGDHSGIGGLGGLGGLGHLGGIGGRRGWGPKGRRGSVSASYSVEIQQIVTPTVITNIDISGSVSIEGGRRGHGLGGLGLGHGLGYGLGHGLGGLGHGGWGSSGDHSGIGGLGGLGGLGHLGGIGGRRGWGPKGRRGSVSASYSVEIQQIVTPTVITNIDISGSVSIEGGRRGHGLGGHGGHGLGHGLGGLGHGLGGLGHGLGGLGHGGLGGIGGRRGWGPKGRRGSVSASYSVEIQQIVTPTVITNIDISGSVSIEGGRRGHGLGGLGLGHGLGHGLGHGLGGLGHGGWGSSGDHSGIGGLGGLGGLGHLGGIGGRRGWGPKGRRGSVSASYSVEIQQIVTPTVITDIEISGSVSIEGGRRGHGLGGLGLGHGLGHGLGHGLGGLGHGGWGSSGDHSGIGGLGGLGGLGHLGGIGGRRGWGPKGRRGSVSASYSVEIQQIVTPTVITNIDISGSVSIEGGRRGHGLGGHGLGHGLGHGLGGLGHGLGGLGHGLGGLGHGGLGGIGGRRGWGPKGRRGSVSASYSVEIQQIVTPTVITDIEISGSVSIEGGRRGHGLGGLGLGHGLGHGLGGLGHGGWGSSGDHSGIGGLGGLGGLGHLGGIGGRRGWGPKGRRGSVSASYSVEIQQIVTPTVITDIEISGSVSIEGGRRGHGLGGLGLGHGLGHGLGHGLGGLGHGGWGSSGDHSGIGGLGGLGGLGHLGGIGGRRGWGPKGRRGSVSASYSVEIQQIVTPTVITNIDISGSVSIEGGRRGHGLGGHGLGHGLGHGLGGLGHGLGGLGHGLGGLGHGGLGGIGGRRGWGPKGRRGSVSASYSVEIQQIVTPTVITDIEISGSVSIEGGRRGHGLGGLGLGHGLGHGLGHGLGGLGHGGWGSSGDHSGIGGLGGLGGLGHLGGIGGLRGWGPKGRRGSVSASYSVEIQQIVTPTVITNIDISGSVSIEGGRRGHGLGGHGLGHGLGHGLGGLGHGLGGLGHGLGGLGHGGLGGIGGRKGWGPKGRRGSVSASYSVEIQQIVTPTVITDIEISGSVSIEGGRRGHGLGGLGLGHGLGHGLGHGLGGLGHGGWGSSGDHSGIGGLGGLGGLGHLGGIGGRRGWGPKGRRGSVSASYSVEIQQIVTPTVITNIDISGSVSIEGGRRGHGLGGHGLGHGLGHGLGGLGHGLGGLGHGLGGLGHGGLGGIGGRKGWGPKGRRGSVSTSYSVEIQQIVTPTVITDIEISGSVSIEGGRRGHGLGGLGLGHGLGHGLGHGLGGLGHGGWGSSGDHSGIGGLGGLGGLGHLGGIGGRRGWGPKGRRGSVSASYSVEIQQIVTPTVITNIDISGSVSIEGGRRGHGLGGLGLGHGLGHGLGHGLGGLGHGGWGSSGDHSGIGGLGGLGGLGHLGGIGGRRGWGPKGRRGSVSASYSVEIQQIVTPTVITNIDISGSVSIEGGRRGHGLGGLGLGHGLGYGLGHGLGGLGHGGWGSSGDHSGIGGLGGLGGLGHLGGIGGRRGWGPKGRRGSVSASYSVEIQQIVTPTVITNIDISGSVSIEGGRRGHGLGGHGLGHGLGHGLGGLGHGLGGLGHGLGGLGHGGLGGIGGRKGWGPKGRRGSVSASYSVEIQQIVTPTVITDIEISGSVSIEGGRRGHGLGGLGLGHGLGHGLGHGLGGLGHGGWGSSGDHSGIGGLGGLGGLGHLGGIGGRRGWGPKGRRGSVSASYSVEIQQIVTPTVITNIDISGSVSIEGGRRGHGLGGLGLGHGLGHGLGHGLGGLGHGGWGSSGDHSGIGGLGGLGGLGHLGGIGGRKGWGPKGRRGSVSASYSVEIQQIVTPTVITNIDISGSVSIEGGRRGHGLGGHGLGHGLGHGLGGLGHGLGGLGHGLGGLGHGGLGGIGGRKGWGPKGRRGSVSASYSVEIQQIVTPTVITDIEISGSVSIEGGRRGHGLGGLGLGHGLGHGLGHGLGGLGHGGWGSSGDHSGIGGLGGLGGLGHLGGIGGRRGWGPKGRRGSVSASYSVEIQQIVTPTVITNIDISGSVSIEGGRRGHGLGGLGLGHGLGHGLGHGLGGLGHGGWGSSGDHSGIGGLGGLGGLGHLGGIGGRRGWGPKGRRGSVSASYSVEIQQIDTPTVITNIDISGSVSIEGGRRGHGLGGLGLGHGLGHGLGHGLGGLGHGGCGSSGDHSGIGGLGGLGGLGHLGGIGGRRGWGPKGRRGSVSASYSVEIQQIVTPTVITNIDISGSVSIEGGRRGHGLGGHGLGHGLGHGLGGLGHGLGGLGHGLGGLGHGGLGGIGGRKGWGPKGRRGSVSASYSVEIQQIVTPTVITDIEISGSVSIEGGRRGHGLGGLGLGHGLGHGLGHGLGGLGHGGWGSSGDHSGIGGLGGLGGLGHLGGIGGRRGWGPKGRRGSVSASYSVEIQQIVTPTVITNIDISGSVSIEGGRRGHGLGGLGLGHGLGHGLGHGLGGLGHGGWGSSGDHSGIGGLGGLGGLGHLGGIGGRKGWGPKGRRGSVSASYSVEIQQIVTPTVITNIDISGSVSIEGGRRGHGLGGHGLGHGLGHGLGGLGHGLGGLGHGLGGLGHGGLGGIGGRKGWGPKGRRGSVSASYSVEIQQIVTPTVITDIEISGSVSIEGGRRGHGLGGLGLGHGLGHGLGHGLGGLGHGGWGSSGDHSGIGGLGGLGGLGHLGGIGGRRGWGPKGRRGSVSASYSVEIQQIVTPTVITNIDISGSVSIEGGRRGHGLGGLGLGHGLGHGLGHGLGGLGHGGWGSSGDHSGIGGLGGLGGLGHLGGIGGRRGWGPKGRRGSVSASYSVEIQQIVTPTVITNIDISGSVSIEGGRRGHGLGGLGLGHGLGHGLGHGLGGLGHGGCGSSGDHSGIGGLGGLGGLGHLGGIGGRRGWGPKGRRGSVSASYSVEIQQIVTPTVITNIDISGSVSIEGGRRGHGLGGHGLGHGLGHGLGGLGHGLGGLGHGLGGLGHGGLGGIGGRKGWGPKGRRGSVSASYSVEIQQIVTPTVITDIEISGSVSIEGGRRGHGLGGLGLGHGLGHGLGHGLGGLGHGGWGSSGDHSGIGGLGGLGGLGHLGGIGGRRGWGPKGRRGSVSASYSVEIQQIVTPTVITNIDISGSVSIEGGRRGHGLGGLGLGHGLGHGLGHGLGGLGHGGWGSSGDHSGIGGLGGLGGLGHLGGIGGRRGWGPKGRRGSVSASYSVEIQQIVTPTVITNIDISGSVSIEGGRRGHGLGGLGLGHGLGHGLGHGLGGLGHGGLGGIGGRRGWGPKGRRGSVSASYSVEIQQIVTPTVITDIEISGSVSIEGGRRGHGLGGLGLGHGLGHGLGHGLGGLGHGGWGSSGDHSGIGGLGGLGGLGHLGGIGGRRGWGPKGRRGSVSASYSVEIQQIVTPTVITNIDISGSVSIEGGRRGHGLGGLGLGHGLGHGLGHGLGGLGHGGWGSSGDHSGIGGLGGLGGLGHLGGIGGRRGWGPKGRRGSVSASYSVEIQQIVTPTVITNIDISGSVSIEGGRRGHGLGGHGLGHGLGHGLGGLGHGLGGLGHGLGGLGHGGLGGIGGRKGWGPKGRRGSVSASYSVEIQQIVTPTVITDIEISGSVSIEGGRRGHGLGGLGLGHGLGHGLGHGLGGLGHGGWGSSGDHSGIGGLGGLGGLGHLGGIGGRRGWGPKGRRGSVSASYSVEIQQIVTPTVITNIDISGSVSIEGGRRGHGLGGLGLGHGLGHGLGHGLGGLGHGGWGSSGDHSGIGGLGGLGGLGHLGGIGGRRGWGPKGRRGSVSASYSVEIQQIVTPTVITNIDISGSVSIEGGRRGHGLGGLGLGHGLGHGLGHGLGGLGHGGLGGIGGRRGWGPKGRRGSVSASYSVEIQQIVTPTVITNIDISGSVSIEGGRRGHGLGGHGLGHGLGHGLGGLGHGLGGLGHGLGELGHGGLGGIGGRRGWGPKGRRGSVSASYSVEIQQIVTPTVITNIDIYGSVSIEGGRRGHGLGGLGLGHGLGHGLGHGLGGLGHGGLGGIGGRRGWGPKGRRGSVSASYSVEIQQIVTPTVITDIEISGSVSIEGGRRGHGIGGLGLGHGLGHGLGGLGGIGGRRGWGPKGRRGSASASYSVEIQHIVTPTVITDIEISGSVSVETGRGGLGNFGALSRLGGGIPRPSVYTTHPDRMTVRAPCKLSDFNILVKVGNLRKDNGNC'  

    blocks = {
     "N": "MRASTLLILFCALQVMPSGDFGKIHITGSSTVIDKLENLLGHGHHLDGHNGLHERILAEDDVIEANSRGEIIEKIISREIISDDN",
     "TR2": "SASASYSVEIOHIVTPTVITDIEISGSVSVETGRGGLGNFGALSRLGGGI",
     "RM1": "SVSASYSVEIQQIVTPTVITNIDISGSVSIEGGRRGHGLGGLGLGHGLGHGLGHGLGGLGHGGWGSSGDHSGIGGLGGLGGLGHLGGIGGRRGWGPKGRRG",
     "TR1": "SYSASDSTEDSGSTEKIIKOIIIVOEKPKHGHHHAKEKIYEEEIIIKKIGDLPKHHIEVSKSISGEKRRRHGKSKHLPKSGLGHGGGLGGIGGNKIWGPKVRRG",
     "C": "PRPSVYTTHPDRMTVRAPCKLSDFNILVKVGNLRKDNGNC"
     }

    block_lengths = {name: len(seq) for name, seq in blocks.items()}
    window_size = 15  # Change if needed

    positions, normalized_scores, alignment_results = calculate_alignment_scores(main_sequence, blocks, window_size)
    plot_alignment_scores(positions, normalized_scores, blocks.keys())
    display_alignment_results(alignment_results, blocks.keys())

    # Output highest probability block for each position
    all_smoothed_scores = [smooth_scores(scores, window_size) for scores in normalized_scores]
    highest_prob_block = []

    for pos in range(len(main_sequence)):
        highest_score = float("-inf")
        best_block = None
        for block_idx, block_name in enumerate(blocks.keys()):
            if pos < len(all_smoothed_scores[block_idx]) and all_smoothed_scores[block_idx][pos] > highest_score:
                highest_score = all_smoothed_scores[block_idx][pos]
                best_block = block_name
        highest_prob_block.append(best_block)

    annotation_data = []
    for pos, block in enumerate(highest_prob_block):
        if block:
            annotation_data.append(f"Position {pos + 1}: {block} has the highest probability")

    # Parse the annotation data to identify regions
    regions = parse_annotations(annotation_data)

    # Print regions
    for region, positions in regions.items():
        print(f"{region}: {positions}")

    # Generate sequence of blocks
    block_sequence = ""
    for region, positions in regions.items():
        for start, end in positions:
            length = end - start + 1
            block_length = block_lengths[region]
            num_repeats = round(length / block_length)
            block_sequence += region * num_repeats

    print("Block Sequence:", block_sequence)

    # Plot the highest probabilities
    plt.figure(figsize=(14, 8))
    for block_name in blocks.keys():
        block_positions = [pos for pos, block in enumerate(highest_prob_block) if block == block_name]
        block_scores = [all_smoothed_scores[list(blocks.keys()).index(block_name)][pos] for pos in block_positions]
        plt.scatter(block_positions, block_scores, label=block_name, s=1)

    plt.xlabel('Position')
    plt.ylabel('Normalized Alignment Score')
    plt.title('Highest Probability Blocks by Position')
    plt.legend()
    plt.show()

if __name__ == "__main__":
    main()
